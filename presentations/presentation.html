<!DOCTYPE html>
<html>
  <head>
    <title>The Timeless Way of Programming</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href="https://fonts.googleapis.com/css?family=Gentium+Book+Basic:400,400i,700,700i&display=swap" rel="stylesheet">
    <style type="text/css">
      body {
        font-family: 'Gentium Book Basic', serif;
      }

      .remark-slide-content {
        background: #fc9;
        color: #321;
      }

      .remark-slide-content.dark {
        /* background: #210; */
        background: #000;
        color: #fc9;
      }

      .big code {
        font-size: 2rem;
      }

      h1, h2, h3 {
        font-weight: normal;
      }

      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono', monospace;
        text-align: left;
      }

      blockquote {
        font-style: italic;
      }

      blockquote p:before {
        display: inline;
        content: '“';
      }

      blockquote p:after {
        display: inline;
        content: '”';
      }

      cite {
        display: block;
        text-align: right;
        padding-right: 3em;
      }

      cite:before {
        display: inline;
        content: '—';
      }

      li {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
      }

      p {
        margin-top: 1em;
        margin-bottom: 1em;
      }

      .remark-slide-content p,
      .remark-slide-content li {
        font-size: 2rem;
      }

      img {
        max-width: 100%;
      }

      .too-tall img {
        height: 500px;
      }

      .small img {
        max-height: 200px;
      }

      .float-left img {
        float: left;
        margin-right: 1em;
      }

      .smaller-font li,
      .smaller-font p {
        font-size: 1.5rem;
      }

      stamp {
        display: block;
        color: red;
        font-family: 'Impact', monospace;
        transform-origin: center;
        transform: rotate(-30deg) translate(2em, -2em);
        font-size: 3em;
      }

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Simplicity

???

This is a talk in five acts, about how and why to write
simple programs.

---

## Four people

- Christopher Alexander
- Sandi Metz
- Katrina Owen
- Kent Beck

???

It synthesizes the ideas of these 4 people. There's really
nothing new in this talk. Just putting existing ideas
together.

During my vacation I was doing a lot of reading, technical
and nontechnical. And it dawned on me that all of these
authors were all kind of saying the same thing, or related
things, about creative work, how it goes wrong, and how to
make it go right again. This talk hopefully weaves together
their collective wisdom into a coherent narrative.

My goal is to pique your interest and hopefully get you to
read some of these writers for yourself. I'll also be
facilitating another refactoring workshop at some point,
probably within the next month, which uses these ideas as
well, so stay tuned for that.

---

## Agenda

- Act One: Failure Modes of Design

- Act Two: Style as a Simulacrum of Mastery

- Act Three: Generative Rules

- Act Four: Beginning Well

- Act Five: The Timeless Way of Programming

???

## Part One: Failure Modes of Design

## Part Two: Style

- Why We Fail to Apply the Ideas of Masters
  - (design ideas come from analyzing the work of master programmers)
  - (masters often can't explain what they actually do)
  - (we cargo-cult the styles of masters)
  - (image-based architecture; image-based programs)
  - (but masters work "without style" - it's an output, not an input)
    - Kent Beck "the system is riding me"
    - C.A. "essentially a building without style"

## Part Three: Generative Rules

- Bridging the Master-Beginner Gap
  - Christopher Alexander: The Fundamental Process
    (C.A. works directly with clients and has built many "user-designed" buildings)
  - Sandi Metz & Katrina Owen: _99 Bottles of OOP_ and the flocking rules
    (whyarecomputers podcast)

## Part Four: Beginner's Mind

- how beginners program
- "the simplest thing that could possibly work"
- why imperative programming is essential
- "duplication is far cheaper than the wrong abstraction"

obstacles to working this way?

- frameworks
- side effects
- can't be naive about architecture

- create abstractions late, target specific problems during refactoring

## Part Five: The Timeless Way of Programming

- The likely character of programs that have unfolded by generative processes
- the flocking rules first produce procedures with no internal duplication and
  a high degree of symmetry (flat conditionals, case statements)
- then a shallow hierarchy of functions, procedures, and data values
- some data values attract functions and procedures to them, becoming objects
- high cohesion, low coupling, symmetry, very little duplication, isolated changes
- but some features that would be discouraged by current practice
  - some long methods
  - apparently missing abstractions, repeated code that hasn't been given a name
    and DRYed out. (this is the result of deferring abstraction)
  - long, flat `case` or `else if` chains, rather than nested conditionals
  - procedural code, not everything is object oriented
  - functional code in mostly-OO programs
  - stateful objects in mostly-functional programs
  - nothing called `Manager`
  - the code will be ordinary, free of pretention
- prefactor on master, (add the feature, postfactor) transactionally

???

In part one I'm going to talk about the failure modes in
software design strategies, including refactoring and
evolutionary design, as I currently see them practiced on
teams.

In part two I'm going to talk about where I think those
design ideas come from, and why it is that we fail time and
again to apply them in satisfactory ways. In short it's
because we derive our rules from the forms created by master
programmers, but masters themselves don't use rules, so
the rules are false; they produce only images, simulacra of
mastery.

In part three I'm going to talk about approaches that have
actually succeeded at communicating between masters and
beginners. These approaches have the common thread of
generativity. They define rules that generate the desired
outcome indirectly, rather than specifying it upfront.

In part four I'm going to talk about the prerequisites for
applying these generative rules, which is essentially that
you have to have an open mind, a beginner's mind, and do
things very naively at first. You have to work without ego,
without images controlling you.

In part five I'll present a vision of the future.
What will programs look like if we adopt
this way of working? What will work feel like?

---

class: center, middle

## Act One: Failure Modes of Design

---

class: center, middle, big

```
if (a condition) {
  do thing 1
} else {
  do thing 2
}
```

???

Several years ago I was working on a mobile app for a client.
This app had a fairly complex UI and the product owner had
asked us to change the order in which data was displayed
depending on actions that the user had recently taken.

A few days into implementing this feature he walked over to
where my pair and I were working and asked us basically
"what's taking so long?" In his mind, the feature was a
simple tweak, and, try as I might, I could not adequately
explain to him why it was not simple. In frustration, he
got a piece of paper and started sketching pseudocode to
show us that yes, it was just two if statements and a
variable, how hard could that be?

The source of our communicative disconnect was this: we'd
structured the code in a way that made this particular
feature complicated to implement. It invalidated some of
our previous design decisions, and it was taking us a lot
of time to revisit and rework those decisions. But the
product owner, who was an amateur programmer himself,
couldn't see that. What he saw was that all the pieces
needed for his feature were already in the app. All that
was needed was for it to behave differently under a
particular condition, and *he knew* a programming
construct that solved that exact problem. If. Then. Else.

---

class: center, middle

# ¯\\\_(ツ)\_/¯

???

At the time I didn't think much of it. It was just one
feature in one codebase that was a little bit complicated
to add. We weren't about to cave under pressure and just
hack in the feature. We knew that keeping our code clean
and refactoring was the only way to keep going fast forever.
The product owner didn't get that, because he wasn't a
technical person. But all that rationalization didn't change
the fact that for this particular feature request, our
carefully designed code was worse at accommodating the
feature than the naive code structure the PM was assuming.

And I started to notice a pattern. On project after
project. We'd test-drive and refactor the code, but we
didn't go fast forever. Features got harder and harder to
add, and the code just seemed to get worse. On several
projects we felt like the only way to
regain the productivity we'd lost was to scrap huge swaths
of code and rewrite them from scratch. In the cases where
we actually had time to perform these rewrites, the
rewritten code ended up no better than the code it replaced.

---

class: center, middle, dark

![](schadenfreude.jpg)

???

These problems fascinated me. No matter how many bad designs
I worked with, each new one always seemed to come from an
unexpected direction.

I started to enjoy rotating onto new projects just to see
what kinds of new and exciting design problems they'd have.

The problems manifested in all sorts of forms.

---

class: center, middle, dark

![A building by I.M. Pei](./i-m-pei.jpg)

???

Sometimes, we'd end up stuck with an elaborate design that
served to showcase one programmer's virtuosity while
bewildering, intimidating, or offending everyone else.

---

class: center, middle, dark

![A street of suburban tract houses](./tract-houses.jpg)

???

Sometimes there were differences of opinion about how best
to write code, and the programmers retreated into
their own little silos. Their styles just sat next to
each other without forming a coherent whole.

---

class: center, middle, dark

![A modern (or is it postmodern?) suburban house](./modern-house.jpg)

???

Frequently, we'd end up with structures where the design
ideas weren't bad _per se_, but they didn't make sense in
context. They seemed to be cargo-culted, derived from
superstition, or from preconceived images of what "good
code" was supposed to look like.

---

class: center, middle, dark

![boxes of stuff](./stuff.jpg)

???

Sometimes we'd divide up a monolithic program into lots of
little modules, but then we'd discover stuff that didn't
seem to fit the organization scheme, and it would just get
stuck somewhere random. A few months later we'd
have a dozen boxes of random junk.

---

class: dark

# <br/><br/><br/>

- ~~external deadline pressure~~
- ~~lack of information~~
- ~~design principles~~
- ?

???

The problems in our code weren't due to external deadline
pressure, and they weren't due to us not having all the
information we needed to make good design decisions when we
needed to make them. If they had been due to those factors,
the rewrites should have rescued our code, but they never
did.

It was also hard to fault the design principles we were
following. We'd seen these recommended in blog post after
blog post, book after book. "Write short methods", "model
your domain with classes", "inject your dependencies".
These were the principles that expert programmers followed,
or so we thought.

So why didn't our designs work for us? Why did we always
feel like we were tripping over our own code?

---

class: middle

> Those who cannot remember the past are condemned to repeat it.

<cite>George Santayana</cite>

???

The problems we felt are not new. They're not even unique
to programming.

The architect Christopher Alexander observed something very
similar happening with the architectural patterns and
design principles he developed.

---

class: center, middle, dark

.too-tall[
![cover of _A Pattern Language_ by Christopher Alexander](./a-pattern-language.jpg)
]


???

But before we dive into that, some background on Alexander,
since he's a fascinating figure who I'm going to reference
multiple times in this talk.

Alexander has spent most of his career in a prolonged
reaction against the dominant, 20th century Western theories
of architecture.

As a young man, he saw a growing modernist movement
producing architecture that felt grotesque and inhuman;
buildings that did not make their inhabitants comfortable
and happy, that were built with more regard
for the architect's reputation than for the people who were
going to use them.

So he set about creating a body of design principles and
techniques that anyone could use to create truly
human-centered buildings and cities.

In the 70s, he wrote this book, _A Pattern Language_, which
was an attempt to document what he'd learned about how to
make such buildings. Everything from how to lay out
a city block to where to place the entrance of a building
and how to structure outdoor space to how tall to make the
windows and how high to make the ceilings. All of this was
based on buildings that Alexander had observed
on his travels around the world, buildings where people were
comfortable and happy and able to use the space effectively.

Alexander thought that this book would help future
architects easily pick up everything he'd learned about how
to make buildings work well.

And, by most measures, the book was a huge success. It had a
profound influence not only on architecture schools but on
the course of object-oriented programming. It inspired the
GOF patterns book.

---

class: center, middle, dark

.too-tall[
![cover of the Gang of Four _Design Patterns_ book](design-patterns.jpg)
]

---

class: center, middle

## problem

???

But there was a problem. Other architects did indeed start
using the patterns, as Alexander had hoped. But Alexander
wasn't exactly thrilled by their creations.

---

class: middle

> [T]he pattern language was actually encouraging people to be a little bit crazy and to conceive of much more intricate relationships than were necessary. [The buildings] were actually disturbing.

---

class: middle

> [P]eople would show me projects they had done and I began to be more and more amazed to realize that, although [the pattern language] worked, all of these projects basically looked like any other buildings of our time.

---

class: middle

> [T]he people who did these projects thought that the buildings were quite different from any they had designed before, perhaps even outrageously so. But their perception was incredibly wrong; and I began to see this happening over and over again—that even a person who is very enthusiastic about all of this work will still be perfectly capable of making buildings that have this mechanical death-like morphology, even with the intention of producing buildings that are alive.

---

class: middle

> So there is the slightly strange paradox that, after all those years of work, the first three books are essentially complete [. . .] but actually do not accomplish anything. The conceptual structures that are presented are just not deep enough to actually break down the barrier. They actually do not do anything.

<cite>Christopher Alexander</cite>

???

And at least part of Alexander's vision came true. Other
architects did read the book and were applying the patterns.
And they'd call him up, and say "look at this thing I built
with your patterns. It's like nothing else I've ever
designed. It works so well."

And Alexander would look at these buildings and see that
the patterns were there but they weren't working together.
They were just making nonsense, or totally banal structures,
not working well for the buildings' inhabitants at all.

And he was forced to conclude that this pattern language that
he'd spent years of his life developing did not work. It
did not achieve its desired goals.

And ultimately I think Alexander learned the hard way that
these other, more junior architects simply didn't yet have
the expertise to approach design the way he approached it.
He'd communicated his ideas in a way that experts like him
could understand, but very few people could actually use
the ideas as he'd presented them.

---

class: center, middle, dark

.too-tall[
![a pattern language](a-pattern-language.jpg)
]

???

So there's all this evidence from Alexander's work and also
the experiences of people in our own industry with design
patterns that there's something deficient about this way of
looking at design. Somehow it doesn't work. In Act 2 I'm
going to dig into why that is.

---

class: center, middle

## Act Two: Style as a Simulacrum of Mastery

---

## The Dreyfus Model of Skill Acquisition

- Novice: Follows rules.
- Competent: Generalizes recurring patterns from examples.
- Proficient: Focuses on the most important aspects of a situation. Uses abstract maxims and heuristics to solve problems.
- Expert: Intuitively responds to situations.
- Master: Is completely "at one" with the work.

???

And in 1980, the Dreyfus brothers proposed this model of
skill acquisition that I think explains Alexander's
experience. Who has heard of the Dreyfus model of skill
acquisition?

It deals with how people learn at different skill levels,
from total beginner to master.

Novices can only follow rules. As they grow in skill,
they learn more and more complex, conditional rules. The
rules become more general, more abstract.
Up through the proficient stage,
reliance on heuristics, maxims and rules of thumb remains
important.

But when you get to the expert stage, things change. Experts
don't think in terms of rules anymore. They somehow intuitively
know what the right thing to do is, and often they can't explain
what they know.

I think it's rare for people to have above proficient-level
programming skill. I'd consider myself a proficient
programmer, but not an expert.

There's a big gap between proficient and expert.

---

class: center, middle

## The proficient&rarr;expert gap

???

The problem that we run into with software design, and the
problem that Alexander ran into with his pattern language,
is in how proficient practitioners try to learn from the
wisdom of experts.

The problem is, experts have a lot of knowledge that we'd
really like to leverage and make accessible to the rest of
us who are merely proficient. But when you ask experts
how they do what they do, their responses are, shall we say,
less than helpful.

---

class: middle

> The sculpture is already complete within the marble block, before I start my work. It is already there, I just have to chisel away the superfluous material.

<cite>Michelangelo</cite>

---

class: center, middle

> I just see the objects.

<cite>Sandi Metz</cite>

---

class: middle

> [M]y attention to the desires of the code can affect how quickly and how well the system finds its desired shape, but the system is riding me much more than I am riding the system.

<cite>Kent Beck</cite>

---

class: center, middle

## How do we learn from experts?

???

And so this problem, how do we learn from experts, is
difficult to solve but also crucially important. We can
learn from experts, or we can learn from experience. But
learning from experience is expensive. Unlike concert
musicians, we software developers don't have a lot of time
to practice. We're expected to learn on the job. The
mistakes we make will affect production systems.

---

class: center, middle

## Style

???

The way we currently incorporate
expert wisdom into our work is by imitating the style of
experts, copying the forms they produce.

This is because, as we've seen, experts work by intuition.
They no longer think in rules. They don't have an algorithm
for what they do. So you can't learn to be an expert by
following the guidelines that the expert follows. There are
no such guidelines.

---

class: middle

maintainable code &rarr; small classes

maintainable code &rarr; high test coverage

maintainable code &rarr; ...

???

Instead, what you can do, is look at programs that are
written by experts, that work well and are easy to maintain,
and see what structural properties they share. For example,
if you look at the code of an expert programmer like, say,
Gary Bernhardt, you see a lot of small classes, only a few
short methods in each one. As you look at more programs
written by experts, you see the same thing.

Okay, you say, so maintainable code implies small classes
and methods. That's one of the elements of good programming
style.

You do this for a bunch of other properties of code.
maintainable code implies high test coverage, dependency
injection, immutable data, whatever.

So you say, great, if I do all of these things, I'll be
programming like an expert.

---

class: center, middle

~~small classes && high test coverage && ... &rarr; maintainable code~~

???

But do small methods, high test coverage, etc. imply maintainability?
Nope! Any first-year logic student will tell you that this
is not valid reasoning. These characteristics are necessary,
but not sufficient, for maintainable code.

Given these observations about how maintainable code looks,
this conclusion does not follow.

Yet we act as if it's true. We cling tightly to these ideas
of style, because without them, we fear we will drown in
our own code.

---

class: middle

> [A]s things are, we have so far beset ourselves with rules,
> and concepts, and ideas of what must be done to make a
> building or a town alive, that we have become afraid of
> what will happen naturally, and convinced that we must
> work within a &ldquo;system&rdquo; and with &ldquo;methods&rdquo;
> since without them our surroundings will come tumbling
> down into chaos.

<cite>Christopher Alexander</cite>

---

class: center, middle

## Style is a cargo cult

---

class: center, middle

## ~~Images~~

???

We have in our minds images of what the code of experts
looks like. But these images do not help us write code
ourselves. When we try to copy them, our designs are hollow
simulacra of experts' designs.

---

class: center, middle

## ~~Style~~

???

But if we don't use a particular style, what *do* we have?
How are we supposed to decide how to write code?

In order to approach an answer to this question, I want to
turn again to Christopher Alexander's work.

---

class: center, middle, dark

![great hall of the Eishin campus](./eishin-hall.jpg)

_&ldquo;essentially a building without style&rdquo;_

???

This is the great hall of a high school campus that
Alexander built in Japan.

Christopher Alexander has referred to this as a building
without style.

The statement may seem strange to us because the building
clearly has identifiable stylistic motifs.

What he means is that he didn't impose a style on it. His
clients didn't start with a preconceived style in mind. They
wanted a building that would stand up and be maintainable
and make their students and faculty happy without being too
expensive. And that's what they got. The apparent style of
the building is the result of solving for those constraints.

---

class: center, middle, dark

![judo hall of the Eishin campus](./judo-hall.jpg)

???

This is a different building on the same campus, the judo
hall.

---

class: center, middle, dark

![porch of the Heisey house](./porch.jpg)

???

And this is the interior of a sunroom-like porch that
Alexander built for a client in Austin, Texas. Again,
Alexander refers to this as a building without style.
In this case, Alexander guided the client through the
process of designing their own house and living space.
He calls this a "user-designed" house (http://www.patternlanguage.com/gallery/houses.html).

---

class: center, middle

## Where does the apparent style of these buildings come from?

???

So Christopher Alexander, if we take him at his word, has
been able somehow to escape the conscious use of style in
his work. Yet these buildings have recognizable
architectural motifs. They are self-consistent. They're not
bland. They seem to have a style, even if Alexander is not
constraining them to fit that style. So where does that
style come from?

---

class: middle

> ...the system finds its desired shape...

<cite>Kent Beck</cite>

> The sculpture is already complete within the marble block.

<cite>Michelangelo</cite>

???

I'd say that the statement about buildings without style is
in the same vein as these quotes that we saw earlier. In
other words, it's a statement made by an expert, a master
of his craft, who sees the work shaping itself under his
effort, unfolding as if by its own volition.

There's a pattern here.

Experts often speak almost mystically about their work
speaking to them or generating itself or revealing itself.
Kent Beck feels he's just the vehicle for the system to
"assume its desired shape". Michelangelo sees statues emerging
from blocks of stone.

---

class: center, middle

_System<sub>n</sub> &rarr; System<sub>n+1</sub>_

???

Because this pattern of experts thinking this way is so
consistent, I want to entertain, for a moment, the
possibility that this might be true in a sense. That the
information to get to step N+1 in an evolving work might be
contained in step N of the work itself and not in the
artist's head, and that, if allowed to evolve under its own
motive power, the system will converge on a particular
shape.

This is very different from the way we currently design
code. Even when we design and refactor incrementally, we
tend to imagine the design as approaching some desired end
state. We have a design in mind and we're refactoring toward
that goal.

But that type of goal-oriented refactoring inherently
imposes an external image of what the code should look like,
which may be at odds with its functionality in subtle ways
that are hard to see in advance. By trying to impose that
image, we can actually damage the code's coherence and
simplicity.

---

class: center, middle, dark

![soap bubble](soap-bubble.jpg)

???

One can imagine every piece of code as having a "desired"
shape: the simplest shape possible that accommodates the
logic and behavior of the code.

The refactoring process reshapes the code incrementally,
moving it closer and closer to that desired shape without
changing its behavior.

As an analogy, consider a soap bubble. The forces of surface
tension and air pressure acting on the bubble shape it into
a sphere. If you magically, and all at once, created a
bubble that was some other shape, say a cube, it wouldn't
last: its own internal forces would either destroy it, or
pull it into a spherical shape.

But there is no law of physics that says a soap bubble must
be round. The roundness of a bubble is an emergent property
of other physical laws dealing with surface tension and the
behavior of gases. And indeed, we can find soap bubbles that
aren't round. If the air pressure around the bubble isn't
uniform, it may have an irregular shape, or a dynamically
changing one.

We want to do the same with code: let the code adjust to its
own desired shape, according to the important forces acting
on it, without adding any undue constraints of our own.

The reason we want to do this is because the shape of the
code is actually the least important aspect of the system.
It comes after everything else: functionality,
maintainability, performance, fault-tolerance, testability,
security, and so on. If code has all of those things, it
doesn't matter what shape it is.

So the secret is this: leave the shape of the code
unspecified, unconstrained, while applying forces that
adjust the functional and nonfunctional aspects of the
code toward their desired states. Whatever shape it ends up
in is a good shape.

When we do this, the shape of the code becomes an emergent
property. We know that whatever rules we formulate for
shaping code must not actually specify its shape. Such rules
couldn't adapt to the infinite variety of possible programs
without being infinitely complex.

The term for such rules is _generative_.

---

class: center, middle

## Act Three: Generative Rules

---

class: middle

> When I play squash and mis-hit or misdirect the ball, I chant, “follow through, follow through, you idiot.”<br/><br/>The law of follow-through is hard to forget - it’s a law, though, that makes little sense: where is its enchantment? How can advice about what to do after you hit a ball make any difference to what happens when you hit it, or before?

---

class: middle

> When you follow through, your arm is aiming at a point well beyond where the racket will contact the ball, so there is no deceleration. “Don’t decelerate, don’t decelerate, you idiot!” It might make a mantra worth repeating, but it isn’t advice you can take.

---

class: middle

> [The follow-through] mantra generates the effect we want - just as a seed generates the flower which eventually blossoms. Just as the wind in the sand generates dune designs and sidewinding sinews and ripples of grains of sand.

<cite>Richard Gabriel</cite>

---

class: center, middle

## follow-through

???

Our problem is we're trying to play squash like an expert
by observing that the expert's arm doesn't decelerate when
they hit the ball and then trying to make our arms do the
same. We haven't yet learned to follow through.

Is it possible to devise a set of generative rules that will
work for something as complex as software?

I think the answer, surprisingly, is yes.

I found my answer in this book, _99 bottles of OOP_, by
Sandi Metz and Katrina Owen.

---

class: center, middle

.too-tall[
![cover of _99 Bottles of OOP_ by Sandi Metz and Katrina Owen](99-bottles-of-oop.jpg)
]

???

The book has a fascinating history which speaks volumes about
the difficulty of communication between experts and nonexperts.

You can hear the authors talk about how the book developed
on this podcast, but I'll summarize here.

https://whyarecomputers.com/3

In (2012?) Katrina was the founder of exercism.io, a website
where people can submit answers to coding challenges and
get feedback from mentors. Sandi was a consultant who flew
from city to city teaching people how to write better code.

---

class: middle

```
99 bottles of beer on the wall, 99 bottles of beer.
Take one down, pass it around, 98 bottles of beer on the wall.

98 bottles...

...

1 bottle of beer on the wall, 1 bottle of beer.
Take it down, pass it around, no more bottles of beer on the wall.

No more bottles of beer on the wall, no more bottles of beer.
Go to the store and buy some more, 99 bottles of beer on the wall.
```

???

There was one particular problem on Exercism that bothered
Katrina. It was the 99 bottles of beer problem. The
challenge was to write a program that printed out the lyrics
to the 99 bottles of beer song with minimal code
duplication. The thing that bothered Katrina about this
problem was that none of the students on Exercism seemed to
be able to come up with a really clean solution. Every
student seemed to "sweep something under the rug", there was
always some detail that didn't fit into the structure of the
rest of the code and had to be duct-taped on as a special
case.

---

class: middle

> I personally thought that maybe there was no good solution to this problem.

<cite>Katrina Owen</cite>

???

Source: https://whyarecomputers.com/3

Katrina began to suspect that maybe there was no clean
solution to this deceptively simple problem, that it was
somehow outside the realm of what object-oriented
programming could handle.

Then, one day, Sandi Metz submitted a solution. Actually,
she submitted three. Each one had a comment at the top
explaining the tradeoffs she made and when you might prefer
this solution over the others. All three beautifully and
cleanly solved the problem.

Katrina was amazed. "no one ever submits more than one solution!"
She wanted to know how Sandi did it.

And Sandi didn't have an answer that satisfied her. "I look
at the code, and I just see the objects. Don't you?"

Intuition.

But Katrina persisted. She really wanted to know exactly
what Sandi was doing when she solved this problem. And,
after much back and forth, Katrina convinced Sandi to write
a book. They were going to write it together. It would be
called _99 Bottles of object oriented programming_. And it
would teach all of those students who had submitted suboptimal
solutions to the 99 bottles problem exactly how Sandi Metz
writes code.

And so they worked together, working and reworking solutions
to this problem. Since they were aiming the book at beginners,
they needed rules. Concrete rules beginners could follow.
So Katrina kept asking Sandi what her rules were, and of
course, Sandi, being the expert, couldn't really give her
a solid answer. They tried a bunch of rules. It seemed
like every rule they came up with had exceptions. Gradually,
they refined the rules, over many iterations of solving the
problem. Finally, they got to a point where they could pretty
much solve the entire 99 bottles problem just by following
the rules they'd developed. No magical intuition required.

---

## The Flocking Rules

1. Find the things that are most alike.
2. Select the smallest difference between them.
3. Make the smallest change that will remove that difference.

???

As an example of a generative rule from the book, here is
a sequence for removing duplication from code.

Metz and Owen call these "flocking rules" after the
generative rules that birds and fish use to move in an
apparently coordinated way without colliding.

I tried out these rules on some thorny code and was
amazed by the results I got. The code came out much cleaner
than I could have imagined when looking at its initial
state.

---

class: center, middle

## Part Four: Beginning Well

---

class: center, middle

_System<sub>n</sub> &rarr; System<sub>n+1</sub>_

???

There is a danger introduced by generative rules.

The rules are not really creative. They merely evolve what
is already present to its logical conclusion. Their output
is a function of the initial state.

That implies that getting the initial state right is of
utmost importance for the rules to work well. So what does
that initial state look like? What's system 0?

---

class: center, middle

_System<sub>0</sub>_

???

If we're not
careful in describing how this initial state must look, we
might discover that finding a good initial state for our
programs is just as intractable as designing the whole
end-state up front.

If you've ever tried to refactor a program that was sliced
up into tiny little methods and classes, with abstraction
boundaries in all the wrong places, you know how hard it is
to refactor code away from certain shapes.

On the other hand, you may have had experiences with code
that was undoubtedly a mess, but wasn't too hard to refactor
into something better. That's the kind of code we want to
use as input to our generative rules. We want to put as
little creative effort as possible into the initial state,
leaving the generative rules to do the heavy lifting.

---

## Well-begun code...

- is correct (as far as the tests can tell us)
- expresses a complete feature
- has no new abstractions

???

"expresses a complete feature" the important thing
here is that the feature we're working on is "done" and we
aren't about to gain new information about the requirements
on the code. The TDD cycle of red-green-refactor encourages
us to refactor whenever the tests pass. But if we do that,
sometimes the designs that unfold from refactoring are
invalidated by the very next test we write. In such a case,
it would have been better to wait for that next test, and
the information it gives us about the forces shaping the
code, before we start to refactor anything. Sandi Metz and
Katrina Owen discuss this at length in _99 bottles_, so I
won't dwell on it here.

---

class: center, middle

## shameless green

???

Sandi and Katrina call this type of code "shameless green"
because the tests pass but it's a little embarrassing; you
wouldn't want to push it to master for sure.

---

class: center, middle

## no abstractions

???

Specifically, what this means is that the code has no
abstractions. The only classes and methods that exist are
those that are absolutely required to be there for some
technical reason.

Generally, this means that the code is imperative,
procedural.

---

class: center, middle

## _&ldquo;Duplication is far cheaper than the wrong abstraction.&rdquo;_

<cite>Sandi Metz</cite>

???

Elsewhere, Sandi Metz has written about this, that it's
better to leave some duplication in the code than to
shoehorn in an abstraction that is likely going to be hard
to undo or work around later. That's why we defer creating
abstractions until we have all the information we're likely
to get about a feature.

---

class: center, middle

## begun well != finished well

???

Of course, beginning well is not enough. You don't want to
ship code that hasn't been refactored. But the generative
rules will take care of that.

---

## Detour: Why is imperative programming the natural paradigm for beginners?

- Pedagogical
  - Robots!
  - No paradigm shift as you drill down towards the metal
  - Analogizes to pen-and-paper calculation
- Technological
  - Debuggers
- Essential
  - Possible to write significant programs without introducing
    any new abstractions

???

All of this seems to presuppose that imperative programming
is the way that beginners naturally program. But that's far
from obvious. It could be that programming tutorials for
beginners focus on imperative code because that's the
natural way, but it could also be that beginners program in
an imperative style because that's the way they're taught.
Which came first? The student or the teacher?

---

class: center, middle

```lisp
(defun multiply-poly (p1 p2)
  (cond ((null p1) nil)
        (t (add-poly
             (constant-multiply-poly (car p1) p2)
             (cons 0 (multiply-poly (cdr p1) p2))))))
```

<cite>Richard Gabriel</cite>

???

Here's some code written by a master Lisp programmer,
Richard Gabriel. It multiplies two polynomials, represented
as lists of the coefficients of their terms. It relies on
two helper functions, `add-poly` and `multiply-poly`, and
a recursive call. The helper functions (not shown here)
also involve recursive calls.

Because functional programming relies so heavily on
recursion, it's virtually impossible to construct a program
without creating and naming new abstractions. Creating these
abstractions involves a level of design foresight and
problem-solving ability that most beginners don't yet have.

Therefore, I feel confident in stating that the naive
approach to programming will always be imperative.

---

class: center, middle

### _&ldquo;When you were new to programming, you wrote simple code. Although you may not have appreciated it at the time, this was a great strength.&rdquo;_

#### —Sandi Metz & Katrina Owen, _99 Bottles of OOP_

???

This is the first sentence of Sandi Metz and Katrina Owen's
book _99 Bottles of OOP_. And it's probably true. Beginners'
code is simple in some sense, if only because it uses a
highly constrained set of forms.

---

class: center, middle

## Act Five:

## The Timeless Way of Programming

???

So far we've talked about the failures of our existing
methods for designing code and possible solutions involving
generative rules.

An important question remains, though: what is the actual
experience of working in a codebase shaped by these
generative rules? What does the code look like? How does it
feel to be there? In short, how do we know that this is
something we actually want to pursue?

In this final section, I hope I can give you a glimpse of
what it might be like to work on software whose design has
unfolded from generative rules. I also hope that you find
this vision exciting enough that you read _99 Bottles of
OOP_ or perhaps Christopher Alexander's books, because they
go into far more detail about these topics than I've been
able to cover here.

This section is not about my opinions on how to structure
code. It's simply my observations of how code *is
structured* when you apply the generative principles from
_99 Bottles of OOP_.

---

class: center, middle, dark

## symmetry

---

class: middle, dark

.float-left.too-tall[
  ![the interior of the great hall of the Eishin campus, showing a hanging light fixture and the quality of the light](great-hall-light.jpg)
]

.smaller-font[
> Complexity (in the bad sense) consists of distinc&shy;tions which unnecessarily complicate a structure. To get simplicity, on the other hand, we need a process which questions every distinction. Any distinction which is not necessary is removed. To remove a distinction we replace it by a symmetry.
]

---

class: middle, dark

.float-left.too-tall[
  ![the interior of the great hall of the Eishin campus, showing a hanging light fixture and the quality of the light](great-hall-light.jpg)
]

.smaller-font[
  > There is an intimate and fundamental connection between arbitrariness, necessity, and symmetry, which says, in a nutshell, this. Everything in nature is symmetrical unless there is a reason for it not to be. When this law is violated, we feel that something is unnatural, and that is the way in which symmetry plays such a fundamental role.

  <cite>Christopher Alexander</cite>
]

---

class: middle

```ruby
download_class =
  case uri.scheme
  when "ssh"
    GitDownload
  when "https"
    HttpsDownload
  when "sftp"
    SftpDownload
  else
    raise NoSuitableClass, "No class for #{uri}"
  end
```

???

Symmetry in code is a concept that I grasp intuitively so
I have a hard time explaining what exactly it is. As best
I can describe it, symmetry is repetition without
duplication. Symmetric code has a rhythm, a consistent
repeating structure.

We often see symmetry and asymmetry in conditionals. Nested
conditionals, or conditionals that use multiple syntaxes
(ternary, switch, if, short-circuiting assignment) are
asymmetrical.

---

class: middle

```ruby
if uri.scheme == "ssh"
  download_class = GitDownload
elsif uri.to_s.start_with? "https"
  download_class = HttpsDownload
end

download_class ||= SftpDownload if uri.scheme == "sftp"

raise NoSuitableClass, "No class for #{uri}" unless download_class
```

???

Here's a contrived example of the same logic written in an
asymmetric way. Looks crazy, but I've worked with code not
too different from this.

---

class: middle

```ruby
s.change 'wō', 'wā', '_$' # Salo 4.15
s.change 'ā', 'ē', 't[wm]_$' # Salo 4.16
s.change 'āu', 'ā', '_' # Salo 4.17
s.change 'j', 'i', 'V\+_' # Salo 4.20
s.change 'V', '', '_\+V' # Salo 4.19
s.change '(CC?)V\1', haplology, 'V_V' # Salo 4.21
s.change 'ñkw', 'mp', '_' # Salo 4.23
s.change 'kw', 'p', '_' # Salo 4.23
s.change 'ñgw', 'mb', '_' # Salo 4.23
```

???

Here's a fragment of a program I wrote that has imperfect
symmetry. The string values look like gibberish because
this is simulating the evolution of the sounds of a language
over time. But the pattern of repeated method calls is a
kind of symmetry. Note that there's still duplication here
which could be DRYed out if I applied the flocking rules.

Still, the symmetry makes this program very easy to change.
I can add a new sound-change rule by just duplicating one
of the lines and changing the values.

And that brings me to the next property of code:

---

class: center, middle, dark

## roughness

---

class: dark, middle

.small.center[
  ![wall of the House of Tiles in Mexico City](house-of-tiles.jpg)
]

> In our time, many of us have been taught to strive for an
> insane perfection that means nothing. To get wholeness,
> you must try instead to strive for this kind of
> perfection, where things that don’t matter are left rough
> and unimportant, and the things that really matter are
> given deep attention. This is a perfection that seems
> imperfect. But it is a far deeper thing.

<cite>Christopher Alexander</cite>

---

class: middle

```ruby
s.change 'wō', 'wā', '_$' # Salo 4.15
s.change 'ā', 'ē', 't[wm]_$' # Salo 4.16
s.change 'āu', 'ā', '_' # Salo 4.17
s.change 'j', 'i', 'V\+_' # Salo 4.20
s.change 'V', '', '_\+V' # Salo 4.19
s.change '(CC?)V\1', haplology, 'V_V' # Salo 4.21
s.change 'ñkw', 'mp', '_' # Salo 4.23
s.change 'kw', 'p', '_' # Salo 4.23
s.change 'ñgw', 'mb', '_' # Salo 4.23
```

???

Could this code be prettier? Yes. Absolutely.

---

class: middle

```ruby
s.change 'wō',       'wā', '_$'       # Salo 4.15
s.change 'ā',        'ē',  't[wm]_$'  # Salo 4.16
s.change 'āu',       'ā',  '_'        # Salo 4.17
s.change 'j',        'i',  'V\+_'     # Salo 4.20
s.change 'V',        '',   '_\+V'     # Salo 4.19
s.change '(CC?)V\1', haplology, 'V_V' # Salo 4.21
s.change 'ñkw',      'mp', '_'        # Salo 4.23
s.change 'kw',       'p',  '_'        # Salo 4.23
s.change 'ñgw',      'mb', '_'        # Salo 4.23
```

???

I could make the spacing more regular. That's very pretty.
But it's actually not easier to read. If I'm reading this
code, looking for something specific or trying to understand
it, this aligned spacing doesn't really help me. It's only
when I'm glancing at the whole thing that I see this surface
prettiness. Plus, the alignment is going to take
effort to maintain as I add more lines.

I certainly don't want to imply that whitespace doesn't
matter. In many cases rearranging whitespace is a very
cost-effective way to make code more readable. But in this
case, I don't think it is.

---

class: middle

```ruby
s.change 'wō', 'wā', '_$'             # Salo 4.15
s.change 'ā', 'ē', 't[wm]_$'          # Salo 4.16
s.change 'āu', 'ā', '_'               # Salo 4.17
s.change 'j', 'i', 'V\+_'             # Salo 4.20
s.change 'V', '', '_\+V'              # Salo 4.19
s.change '(CC?)V\1', haplology, 'V_V' # Salo 4.21
s.change 'ñkw', 'mp', '_'             # Salo 4.23
s.change 'kw', 'p', '_'               # Salo 4.23
s.change 'ñgw', 'mb', '_'             # Salo 4.23
```

???

The one part of this that I might actually keep is the
alignment of the comments, so I can easily cross-reference
with the linguistics book I was basing this code on.

I think this is a good compromise.

---

class: center, middle, dark

## a &ldquo;shallow mess&rdquo;

???

The way I see this applying to code is, we might end up with
code that's a little bit messy. But it's messy in a very
specific way that makes it easy to clean up when and where
we need to. I call this a shallow mess.

A few days ago I was in my kitchen with some
friends, making lunch. They were standing around making and
drinking tea. And I suddenly had the strange awareness that,
while the kitchen was pretty messy, with pots and pans left
out and boxes of tea out on the counter, it was working
smoothly. We were all gliding past each other as we walked
around and went about our various tasks. The mess, for
whatever reason, didn't seem to be in our way.

I think the reason is, this mess was shallow. If we needed
to clean something up or put something away, that was a
simple, one-step process.

---

class: center, middle, dark

## shallow hierarchies

???

One side effect of using the flocking rules is that you
don't end up with unnecessary indirection. Often, it's
possible to DRY up duplicated code without adding any new
methods or classes. The results are counterintuitive to
many people, but when you follow the flocking rules, they
are generated, effortlessly.

This means the methods at the top of your call stack are
somewhat longer than is currently in vogue, but they're
very direct: it's easy to see what the code is doing, and
you don't have to go digging through a lot of layers to
find the piece you need to change or debug.

---

class: center, middle, dark

## multiple paradigms

???

If we're programming without preconceptions of style,
there's little reason to commit to a paradigm
(e.g. object-oriented, procedural, or functional) up front.

Instead, we're free to use whatever paradigm makes sense
for the problem at hand.

I've written a fair amount of multiparadigm code on my own
personal projects, as well as some at work. Many languages
(Java, Golang, Kotlin, JavaScript, Ruby, Rust) now embrace
multiple paradigms.

Simply due to the nature of these paradigms and what each
one is good at, I predict that we'll see designs with
layers, where the top layer of the call graph is procedural,
then we have stateful objects in the middle layer, and at
the bottom, a rock-solid layer of stateless, pure functions.
The lower-down you go in the layering, the more
Most of the business logic of programs will be concentrated
in the upper layers, with perhaps a few custom
data-transformation functions written for each program.

---

class: center, middle, dark

## truth to materials

---

class: center, middle, dark

## pair programming

???

Finally, I just want to touch on what the feeling of working
in this type of codebase would be like. Above all I think
the experience of pairing would be very different. Often
when I'm pairing my partner and I have conflicting design
ideas and we either have to try first one and then the other
or argue for a long time before we pick one. With generative
rules for refactoring, we can choose small problems to fix
in the code, and address them very quickly.

As I touched on earlier, we develop an intuition for when
something's not right with a situation before we are able
to respond intuitively or even reason out a solution. The
Dreyfus model describes this and my experience matches it.
This means that even junior developers will be able to
participate effectively in refactoring with generative
rules, because they can spot problems, often quicker than
more senior programmers can.

My hope is that these factors will result in both people
feeling heard and feeling like they are making valuable
contributions to the pairing session.

---

class: middle, dark

> When I&rsquo;m working on a problem, I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.

<cite>R. Buckminster Fuller</cite>

---

## References

- Christopher Alexander
  - _The Timeless Way of Building_
  - _A Pattern Language_
  - _The Nature of Order_
- Kent Beck
  - _Extreme Programming Explained, 2nd. Ed_
- Sandi Metz & Katrina Owen
  - _99 Bottles of OOP_
- Sarah Mei
  - "Livable Code"
- Anjana Vakil
  - "Programming Across Paradigms"
- Jessica Kerr
  - "Functional Principles for Object-Oriented Developers"
- Richard Gabriel
  - _Patterns of Software: Tales from the Software Community_

    </textarea>
    <script src="./remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
