<!DOCTYPE html>
<html>
  <head>
    <title>The Timeless Way of Programming</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href="https://fonts.googleapis.com/css?family=Gentium+Book+Basic:400,400i,700,700i&display=swap" rel="stylesheet">
    <style type="text/css">
      body {
        font-family: 'Gentium Book Basic', serif;
      }

      .remark-slide-content {
        background: #fc9;
        color: #321;
      }

      .remark-slide-content.dark {
        /* background: #210; */
        background: #000;
        color: #fc9;
      }

      .big code {
        font-size: 2rem;
      }

      h1, h2, h3 {
        font-weight: normal;
      }

      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono', monospace;
        text-align: left;
      }

      blockquote {
        font-style: italic;
      }

      blockquote p:before {
        display: inline;
        content: '“';
      }

      blockquote p:after {
        display: inline;
        content: '”';
      }

      cite {
        display: block;
        text-align: right;
        padding-right: 3em;
      }

      cite:before {
        display: inline;
        content: '—';
      }

      li {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
      }

      p {
        margin-top: 1em;
        margin-bottom: 1em;
      }

      .remark-slide-content p,
      .remark-slide-content li {
        font-size: 2rem;
      }

      img {
        max-width: 100%;
      }

      .too-tall img {
        height: 500px;
      }

      stamp {
        display: block;
        color: red;
        font-family: 'Impact', monospace;
        transform-origin: center;
        transform: rotate(-30deg) translate(2em, -2em);
        font-size: 3em;
      }

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Simplicity

???

This is a talk in five acts, about how and why to write
simple programs.

---

## Five people

- Christopher Alexander
- Sandi Metz
- Katrina Owen
- Kent Beck
- Shunryu Suzuki

???

It synthesizes the ideas of these 5 people. There's really
nothing new in this talk. Just putting existing ideas
together.

During my vacation I was doing a lot of reading, technical
and nontechnical. And it dawned on me that all of these
authors were all kind of saying the same thing, or related
things, about creative work, how it goes wrong, and how to
make it go right again. This talk hopefully weaves together
their collective wisdom into a coherent narrative.

My goal is to pique your interest and hopefully get you to
read some of these writers for yourself. I'll also be
facilitating another refactoring workshop at some point,
probably within the next month, which uses these ideas as
well, so stay tuned for that.

---

## Agenda

- Act One: Failure Modes of Design

- Act Two: Style as a Simulacrum of Mastery

- Act Three: Generativity

- Act Four: Beginner's Mind

- Act Five: The Timeless Way of Programming

???

## Part One: Failure Modes of Design

## Part Two: Style

- Why We Fail to Apply the Ideas of Masters
  - (design ideas come from analyzing the work of master programmers)
  - (masters often can't explain what they actually do)
  - (we cargo-cult the styles of masters)
  - (image-based architecture; image-based programs)
  - (but masters work "without style" - it's an output, not an input)
    - Kent Beck "the system is riding me"
    - C.A. "essentially a building without style"

## Part Three: Generativity

- Bridging the Master-Beginner Gap
  - Christopher Alexander: The Fundamental Process
    (C.A. works directly with clients and has built many "user-designed" buildings)
  - Sandi Metz & Katrina Owen: _99 Bottles of OOP_ and the flocking rules
    (whyarecomputers podcast)

## Part Four: Beginner's Mind

- how beginners program
- "the simplest thing that could possibly work"
- why imperative programming is essential
- "duplication is far cheaper than the wrong abstraction"

obstacles to working this way?

- frameworks
- side effects
- can't be naive about architecture

- create abstractions late, target specific problems during refactoring

## Part Five: The Timeless Way of Programming

- The likely character of programs that have unfolded by generative processes
- the flocking rules first produce procedures with no internal duplication and
  a high degree of symmetry (flat conditionals, case statements)
- then a shallow hierarchy of functions, procedures, and data values
- some data values attract functions and procedures to them, becoming objects
- high cohesion, low coupling, symmetry, very little duplication, isolated changes
- but some features that would be discouraged by current practice
  - some long methods
  - apparently missing abstractions, repeated code that hasn't been given a name
    and DRYed out. (this is the result of deferring abstraction)
  - long, flat `case` or `else if` chains, rather than nested conditionals
  - procedural code, not everything is object oriented
  - functional code in mostly-OO programs
  - stateful objects in mostly-functional programs
  - nothing called `Manager`
  - the code will be ordinary, free of pretention
- prefactor on master, (add the feature, postfactor) transactionally

???

In part one I'm going to talk about the failure modes in
software design strategies, including refactoring and
evolutionary design, as I currently see them practiced on
teams.

In part two I'm going to talk about where I think those
design ideas come from, and why it is that we fail time and
again to apply them in satisfactory ways. In short it's
because we derive our rules from the forms created by master
programmers, but masters themselves don't use rules, so
the rules are false; they produce only images, simulacra of
mastery.

In part three I'm going to talk about approaches that have
actually succeeded at communicating between masters and
beginners. These approaches all have the common thread of
generativity. They define rules that generate the desired
outcome indirectly, rather than specifying it upfront.

In part four I'm going to talk about the prerequisites for
applying these generative rules, which is essentially that
you have to have an open mind, a beginner's mind, and do
things very naively at first. You have to work without ego,
without images controlling you.

In part five I'll present a vision of the future.
What will programs look like if we adopt
this way of working? What will work feel like?

---

class: center, middle

## Act One: Failure Modes of Design

---

class: center, middle, big

```
if ... {
  do thing 1
} else {
  do thing 2
  if ... {
    do thing 3
  }
}
```

???

Several years ago I was working on a mobile app for a client.
This app had a fairly complex UI and the product owner had
asked us to change the order in which data was displayed
depending on actions that the user had recently taken.

A few days into implementing this feature he walked over to
where my pair and I were working and asked us basically
"what's taking so long?" In his mind, the feature was a
simple tweak, and, try as I might, I could not adequately
explain to him why it was not simple. In frustration, he
got a piece of paper and started sketching pseudocode to
show us that yes, it was just two if statements and a
variable, how hard could that be?

The source of our communicative disconnect was this: we'd
structured the code in a way that made this particular
feature complicated to implement. It invalidated some of
our previous design decisions, and it was taking us a lot
of time to revisit and rework those decisions. But the
product owner, who was an amateur programmer himself,
couldn't see that. What he saw was that all the pieces
needed for his feature were already in the app. All that
was needed was for it to behave differently under a
particular condition, and *he knew* a programming
construct that solved that exact problem. If. Then. Else.

---

class: center, middle

# ¯\\\_(ツ)\_/¯

???

At the time I didn't think much of it. It was just one
feature in one codebase that was a little bit complicated
to add. We weren't about to cave under pressure and just
hack in the feature. We knew that keeping our code clean
and refactoring was the only way to keep going fast forever.
The product owner didn't get that, because he wasn't a
technical person. But all that rationalization didn't change
the fact that for this particular feature request, our
carefully designed code was worse at accommodating the
feature than the naive code structure the PM was assuming.

And I started to notice a pattern. On project after
project. We'd test-drive and refactor the code, but we
didn't go fast forever. Features got harder and harder to
add, and the code just seemed to get worse. On several
projects we felt like the only way to
regain the productivity we'd lost was to scrap huge swaths
of code and rewrite them from scratch. In the cases where
we actually had time to perform these rewrites, the
rewritten code ended up no better than the code it replaced.

---

class: center, middle, dark

![](schadenfreude.jpg)

???

These problems fascinated me. No matter how many bad designs
I worked with, each new one always seemed to come from an
unexpected direction.

I started to enjoy rotating onto new projects just to see
what kinds of new and exciting design problems they'd have.

The problems manifested in all sorts of forms.

---

class: center, middle, dark

![A building by Frank Gehry in Prague](./gehry-building.jpg)

???

Sometimes, we'd end up stuck with an elaborate design that
served to showcase one programmer's virtuosity while
bewildering, intimidating, or offending everyone else.

---

class: center, middle, dark

![A street of suburban tract houses](./tract-houses.jpg)

???

Sometimes there were differences of opinion about how best
to write code, and the programmers retreated into
their own little silos. Their styles just sat next to
each other without forming a coherent whole.

---

class: center, middle, dark

![A modern (or is it postmodern?) suburban house](./modern-house.jpg)

???

Frequently, we'd end up with structures where the design
ideas weren't bad _per se_, but they didn't make sense in
context. They seemed to be cargo-culted, derived from
superstition, or from preconceived images of what "good
code" was supposed to look like.

---

class: center, middle, dark

![boxes of stuff](./stuff.jpg)

???

Sometimes we'd divide up a monolithic program into lots of
little modules, but then we'd discover stuff that didn't
seem to fit the organization scheme, and it would just get
stuck somewhere random. A few months later we'd
have a dozen boxes of random junk.

---

class: dark

# <br/><br/><br/>

- ~~external deadline pressure~~
- ~~lack of information~~
- ~~design principles~~
- ?

???

The problems in our code weren't due to external deadline
pressure, and they weren't due to us not having all the
information we needed to make good design decisions when we
needed to make them. If they had been due to those factors,
the rewrites should have rescued our code, but they never
did.

It was also hard to fault the design principles we were
following. We'd seen these recommended in blog post after
blog post, book after book. "Write short methods", "model
your domain with classes", "inject your dependencies".
These were the principles that expert programmers followed,
or so we thought.

So why didn't our designs work for us? Why did we always
feel like we were tripping over our own code?

---

class: middle

> Those who cannot remember the past are condemned to repeat it.

<cite>George Santayana</cite>

???

This is nothing new. We need to learn from the past to
avoid repeating it.

---

class: center, middle, dark

.too-tall[
![cover of _A Pattern Language_ by Christopher Alexander](./a-pattern-language.jpg)
]


???

The architect Christopher Alexander observed something very
similar happening in architecture.

He was frustrated by 20th century theories of architecture that felt
grotesque and inhuman, that produced buildings that did not
make their inhabitants comfortable and happy, and that
were generally built with more regard for the architect's
reputation than for the people who would use them.

In the 70s, he wrote this book, _A Pattern Language_, which
was an attempt to document what he and the architects he
worked with knew about how to make buildings that worked
well for their inhabitants. Everything from how to lay out
a city block to where to place the entrance of a building
and how to structure outdoor space to how tall to make the
windows and how high to make the ceilings. All of this was
based on buildings that Alexander had designed, or observed
on his travels around the world, buildings where people were
comfortable and happy and able to use the space effectively.

Alexander thought that this book would help future
architects easily pick up everything he'd learned about how
to make buildings work well.

And this book had a profound influence on the course of
object-oriented programming. It inspired the GOF patterns
book.

---

class: center, middle, dark

.too-tall[
![cover of the Gang of Four _Design Patterns_ book](design-patterns.jpg)
]

---

class: middle

> [T]he pattern language was actually encouraging people to be a little bit crazy and to conceive of much more intricate relationships than were necessary. [The buildings] were actually disturbing.

---

class: middle

> [P]eople would show me projects they had done and I began to be more and more amazed to realize that, although [the pattern language] worked, all of these projects basically looked like any other buildings of our time.

---

class: middle

> [T]he people who did these projects thought that the buildings were quite different from any they had designed before, perhaps even outrageously so. But their perception was incredibly wrong; and I began to see this happening over and over again—that even a person who is very enthusiastic about all of this work will still be perfectly capable of making buildings that have this mechanical death-like morphology, even with the intention of producing buildings that are alive.

---

class: middle

> So there is the slightly strange paradox that, after all those years of work, the first three books are essentially complete [. . .] but actually do not accomplish anything. The conceptual structures that are presented are just not deep enough to actually break down the barrier. They actually do not do anything.

<cite>Christopher Alexander</cite>

???

And at least part of Alexander's vision came true. Other
architects did read the book and were applying the patterns.
And they'd call him up, and say "look at this thing I built
with your patterns. It's like nothing else I've ever
designed. It works so well."

And Alexander would look at these buildings and see that
the patterns were there but they weren't working together.
They were just making nonsense, or totally banal structures,
not working well for the buildings' inhabitants at all.

And he was forced to conclude that this pattern language that
he'd spent years of his life developing did not work. It
did not achieve its desired goals.

And ultimately I think Alexander learned the hard way that
these other, more junior architects simply didn't yet have
the expertise to approach design the way he approached it.
He'd communicated his ideas in a way that experts like him
could understand, but very few people could actually use
the ideas as they were structured.

---

class: center, middle, dark

.too-tall[
![a pattern language](a-pattern-language.jpg)
]

???

So there's all this evidence from Alexander's work and also
the experiences of people in our own industry with design
patterns that there's something deficient about this way of
looking at design. Somehow it doesn't work. In Act 2 I'm
going to dig into why that is.

---

class: center, middle

## Act Two: Style as a Simulacrum of Mastery

---

## The Dreyfus Model of Skill Acquisition

- Novice: Follows rules.
- Competent: Generalizes recurring patterns from examples.
- Proficient: Focuses on the most important aspects of a situation. Uses abstract maxims and heuristics to solve problems.
- Expert: Intuitively responds to situations.
- Master: Is completely "at one" with the work.

???

And in 1980, the Dreyfus brothers proposed this model of
skill acquisition that I think explains Alexander's
experience. Who has heard of the Dreyfus model of skill
acquisition?

It deals with how people learn at different skill levels,
from total beginner to master.

Novices can only follow rules. As they grow in skill,
they learn more and more complex, conditional rules. The
rules become more general, more abstract.
Up through the proficient stage,
reliance on heuristics, maxims and rules of thumb remains
important.

But when you get to the expert stage, things change. Experts
don't think in terms of rules anymore. They somehow intuitively
know what the right thing to do is, and often they can't explain
what they know.

I think it's rare for people to have above proficient-level
programming skill. I'd consider myself a proficient
programmer, but not an expert.

There's a big gap between proficient and expert.

---

class: center, middle

## The proficient&rarr;expert gap

???

The problem that we run into with software design, and the
problem that Alexander ran into with his pattern language,
is in how proficient practitioners try to learn from the
wisdom of experts.

The problem is, experts have a lot of knowledge that we'd
really like to leverage and make accessible to the rest of
us who are merely proficient. But when you ask experts
how they do what they do, their responses are, shall we say,
less than helpful.

---

class: middle

> The sculpture is already complete within the marble block, before I start my work. It is already there, I just have to chisel away the superfluous material.

<cite>Michelangelo</cite>

---

class: center, middle

> I just see the objects.

<cite>Sandi Metz</cite>

---

class: middle

> [M]y attention to the desires of the code can affect how quickly and how well the system finds its desired shape, but the system is riding me much more than I am riding the system.

<cite>Kent Beck</cite>

---

class: center, middle

## How do we learn from experts?

???

And so this problem, how do we learn from experts, is
difficult to solve but also crucially important. We can
learn from experts, or we can learn from experience. But
learning from experience is expensive. Unlike concert
musicians, we software developers don't have a lot of time
to practice. We're expected to learn on the job. The
mistakes we make will affect production systems.

---

## Style

???

The way we currently incorporate
expert wisdom into our work is by imitating the style of
experts, copying the forms they produce.

This is because, as we've seen, experts work by intuition.
They no longer think in rules. They don't have an algorithm
for what they do. So you can't learn to be an expert by
following the guidelines that the expert follows. There are
no such guidelines.

---

maintainable code &rarr; small classes

maintainable code &rarr; high test coverage

maintainable code &rarr; ...

???

Instead, what you can do, is look at programs that are
written by experts, that work well and are easy to maintain,
and see what structural properties they share. For example,
if you look at the code of an expert programmer like, say,
Gary Bernhardt, you see a lot of small classes, only a few
short methods in each one. As you look at more programs
written by experts, you see the same thing.

Okay, you say, so maintainable code implies small classes
and methods. That's one of the elements of good programming
style.

You do this for a bunch of other properties of code.
maintainable code implies high test coverage, dependency
injection, immutable data, whatever.

So you say, great, if I do all of these things, I'll be
programming like an expert.

---

class: center, middle

~~small classes && high test coverage && ... &rarr; maintainable code~~

???

But do small methods, high test coverage, etc. imply maintainability?
Nope! Any first-year logic student will tell you that this
is not valid reasoning. These characteristics are necessary,
but not sufficient, for maintainable code.

Given these observations about how maintainable code looks,
this conclusion does not follow.

Yet we act as if it's true. We cling tightly to these ideas
of style, because without them, we fear we will drown in
our own code.

---

class: middle

> [A]s things are, we have so far beset ourselves with rules,
> and concepts, and ideas of what must be done to make a
> building or a town alive, that we have become afraid of
> what will happen naturally, and convinced that we must
> work within a &ldquo;system&rdquo; and with &ldquo;methods&rdquo;
> since without them our surroundings will come tumbling
> down into chaos.

<cite>Christopher Alexander</cite>

---

class: center, middle

## Style is a cargo cult

---

class: center, middle

## ~~Images~~

???

We have in our minds images of what the code of experts
looks like. But these images do not help us write code
ourselves. When we try to copy them, our designs are hollow
simulacra of experts' designs.

---

class: center, middle

## ~~Style~~

---

class: center, middle, dark

![great hall of the Eishin campus](./eishin-hall.jpg)

_&ldquo;essentially a building without style&rdquo;_

???

Christopher Alexander has referred to this as a building
without style.

The statement may seem strange to us because the building
clearly has identifiable stylistic motifs.

What he means is that he didn't impose a style on it. His
clients wanted a building of a certain size, that would
fit in a particular budget, would be structurally sound,
and would make the students and faculty happy, that would
be a pleasant place to be. The design, the apparent style
of the building, evolved entirely from those constraints.

---

class: center, middle, dark

![judo hall of the Eishin campus](./judo-hall.jpg)

---

class: center, middle, dark

![porch of the Heisey house](./porch.jpg)

---

???

Let's go back to these quotes.

Experts often speak almost mystically about their work
speaking to them or generating itself or revealing itself.
Kent Beck feels he's just the vehicle for the system to
"assume its desired shape". Michelangelo sees statues emerging
from blocks of stone.

I want to entertain, for a moment, the possibility that this
might be true in a sense. That the information to get to
step N+1 in an evolving work might be contained in step N of
the work itself and not in the artist's head. In effect,
I am saying that there is a shape that code "wants" to be,
along the same lines as what Kent Beck is saying. Maybe
all we have to do is find a process that will tell us what
that shape is.

Our current way of thinking about design is static,
declarative. We specify or imagine a shape for the system
and then we go about constructing a system that has that
shape. Or we imagine a set of static constraints—invariants
that our design must solve for. And then we attempt to
create a design that meets all those constraints.

Even when we design and refactor incrementally, we tend to
imagine the design as approaching some desired end state.
We have a design in mind and we're refactoring toward that
goal.

This has, in the past, seemed to me like the only sane way
of doing things. Refactoring without a goal seemed absurd. I
now think that this way of thinking is circular: the only
reason it seemed absurd to refactor without a goal is that I
only undertook refactoring in pursuit of particular design
goals.

I propose that we need a new way of thinking, in which the
design is dynamic, continually evolving, and does not
approach a specific end state. In this model of the
development process, refactoring is driven not by the
programmer's vision of design but by the shape of the
code as it exists.

---

class: center, middle, dark

![soap bubble](soap-bubble.jpg)

???

One can imagine every piece of code as having a "desired"
shape: the simplest shape possible that accommodates the
logic and behavior of the code.

The refactoring process reshapes the code incrementally,
moving it closer and closer to that desired shape without
changing its behavior.

As an analogy, consider a soap bubble. The forces of surface
tension and air pressure acting on the bubble shape it into
a sphere. If you created a bubble that was not a sphere,
its own internal forces would pull it into this shape.

We want to do the same with code: let the code adjust to its
own desired shape.

But it is not at all clear how to create a process that will
do this.

---

> What [D’Arcy] Thompson insisted on was that every form is basically the end result of a certain growth process. When I first read this I felt that of course the form in a purely static sense is equilibrating certain forces and that you could say that it was even the product of those forces—in a non-temporal, non-dynamic sense, as in the case of a raindrop, for example, which in the right here and now is in equilibrium with the air flow around it, the force of gravity, its velocity, and so forth—but that you did not really have to be interested in how it actually got made. Thompson however was saying that everything is the way it is today because it is the result of a certain history—which of course includes how it got made. But at the time I read this I did not really understand it very well; whereas I now realize that he is completely right.

<cite>Christopher Alexander</cite>

---

## Part Three: Generativity

(Richard Gabriel quote on generative advice)

---


---

Our problem is we're trying to play squash like an expert
by observing that the expert's arm doesn't decelerate when
they hit the ball and then trying to make our arms do the
same. We haven't yet learned to follow through.

---

Is it possible to devise a set of generative rules that will
work for something as complex as software?

I think the answer, surprisingly, is yes.

---

C.A. is one of the rare masters who can explain what he
does. I know he is explaining it, and not just fooling
himself into thinking he's explained it, because he guides
many of his clients through the process of designing their
own individual rooms and buildings.

He has many strong and controversial opinions about
architecture, but the crux of them is not "design buildings
that look like mine, because I am the best architect," but
"use the process that I use, because it is able to guide
total beginners, people who have never thought of being
architects, to create buildings that work well for them.

---

The details of his process aren't particularly relevant to
us, because we make programs, not buildings, but one facet
of his process that should be stressed is that he does not
impose a style on his buildings. Here is a building he
designed, the great hall of a high school in Japan. He wrote
that this is "essentially a building without style."

---

Here's the porch of a house he built in Austin, Texas. This
was a case where he worked closely with the people who would
be living in the house, guiding them through the process.

He also calls this "a building without style."

---

So what does this mean, "building without style"? That's
kind of a strange thing for an architect to say about one
of their own buildings. Certainly these buildings have
stylistic elements that could be imitated. We could imagine
another building that had the same style, the same
architectural motifs, as this great hall.

But what he means is that he did not impose a style on the
buildings. The apparent style is the output of the process.
Everything in these buildings, from the shape of the largest
rooms down to the smallest ornaments and details, is
generated by the process.

---

After I read about Alexander's work, I began to wonder what
a "program without style" would look like? How would the
code be shaped?

I found my answer in this book, _99 bottles of OOP_, by
Sandi Metz and Katrina Owen.

---

The book has a fascinating history which speaks volumes about
the difficulty of communication between experts and nonexperts.

You can hear the authors talk about how the book developed
on this podcast, but I'll summarize here.

https://whyarecomputers.com/3

---

In (2012?) Katrina was the founder of exercism.io, a website
where people can submit answers to coding challenges and
get feedback from mentors. Sandi was a consultant who flew
from city to city teaching people how to write better code.

There was one particular problem on Exercism that bothered
Katrina. It was the 99 bottles of beer problem. The
challenge was to write a program that printed out the lyrics
to the 99 bottles of beer song with minimal code
duplication. The thing that bothered Katrina about this
problem was that none of the students on Exercism seemed to
be able to come up with a really clean solution. Every
student seemed to "sweep something under the rug", there was
always some detail that didn't fit into the structure of the
rest of the code and had to be duct-taped on as a special
case. Katrina began to suspect that maybe there was no clean
solution to this deceptively simple problem, that it was
somehow outside the realm of what object-oriented
programming could handle.

Then, one day, Sandi Metz submitted a solution. Actually,
she submitted three. Each one had a comment at the top
explaining the tradeoffs she made and when you might prefer
this solution over the others. All three beautifully and
cleanly solved the problem.

Katrina was amazed. "no one ever submits more than one solution!"
She wanted to know how Sandi did it.

And Sandi didn't have an answer that satisfied her. "I look
at the code, and I just see the objects. Don't you?"

Intuition.

But Katrina persisted. She really wanted to know exactly
what Sandi was doing when she solved this problem. And,
after much back and forth, Katrina convinced Sandi to write
a book. They were going to write it together. It would be
called _99 Bottles of object oriented programming_. And it
would teach all of those students who had submitted suboptimal
solutions to the 99 bottles problem exactly how Sandi Metz
writes code.

And so they worked together, working and reworking solutions
to this problem. Since they were aiming the book at beginners,
they needed rules. Concrete rules beginners could follow.
So Katrina kept asking Sandi what her rules were, and of
course, Sandi, being the expert, couldn't really give her
a solid answer. They tried a bunch of rules. It seemed
like every rule they came up with had exceptions. Gradually,
they refined the rules, over many iterations of solving the
problem. Finally, they got to a point where they could pretty
much solve the entire 99 bottles problem just by following
the rules they'd developed. No magical intuition required.

---

## The Flocking Rules

1. Find the things that are most alike.
2. Select the smallest difference between them.
3. Make the smallest change that will remove that difference.

---

class: center, middle

## Part Four: Beginner's Mind

---

class: center, middle

## The Blank Page

???

There is a missing piece to the rules that Sandi and Katrina
developed. The missing piece is what do you do if you don't
have any code yet?

When we're starting a project or even a new feature for an
existing project, we have to confront the problem of the
blank page. And when we have nothing, it is very hard to
avoid imposing a style on our code. We start programming
from an assumption of paradigm: OO, FP, MVC, reactive,
concurrent, or whatever else. Often the very first decision
we make on our project is to choose a framework, and often
these frameworks limit us to a particular view.

---

class: center, middle

## shameless green

???

Sandi and Katrina assume that your refactoring process
starts from something they call "shameless green". The
tests pass but the code makes no assumptions about future
requirements.

---

class: center, middle

## no abstractions

???

Specifically, what this means is that the code has no
abstractions. The only classes and methods that exist are
those that are absolutely required to be there for some
technical reason.

Generally, this means that the code is imperative,
procedural.

---

class: center, middle

## writing like a beginner

???

What's intriguing to me about this is that it very closely
mirrors how I wrote programs when I was just starting out.
To write shameless green code means writing like a beginner.

---

> In the beginner's mind there is no thought "I have attained something." All self-centered thoughts limit our vast mind. When we have no thought of achievement, no thought of self, we are true beginners. Then we can really learn something.

<cite>Shunryu Suzuki, _Zen Mind, Beginner's Mind_</cite>

???

And in particular it means letting go of any egoistic desire
to impose a form on our program.

---

class: center, dark

![The Eishin Great Hall](./eishin-hall.jpg)

_&ldquo;essentially a building without style.&rdquo;_

???

In his book The Nature of Order, Christopher Alexander
called this, the main hall of a high school campus he built
in Japan, "essentially a building without style", which is
kind of a strange thing for an architect to say about one of
his own buildings. Clearly we can see some stylistic
elements of this building and imagine applying them to some
other structure. But I think that's not what Alexander
meant. I think what he meant is that style was not a
constraint of the process used to create this building. His
clients didn't start with a preconceived style in mind. They
wanted a building that would stand up and be maintainable
and make their students and faculty happy without being too
expensive. And that's what they got. The apparent style of
the building is the result of solving for those constraints.

---

class: dark, center, middle

![Porch of the Heisey House](./porch.jpg)

???

Here's another building by Alexander. The interior of a porch
he built for a home in Austin, Texas. Again, he calls this
a building without style.

---

class: center, middle

## The Texture of Mastery

???

---

class: middle

> My vision can shape initial direction, and my attention to the desires of the code can affect how quickly and how well the system finds its desired shape, but the system is riding me much more than I am riding the system.

<cite>Kent Beck</cite>

---

class: center, middle

# Beginner&rsquo;s Mind

### _The Escape from Style_

???

There are only four things you need to know in order to
program. Anyone want to guess what they are?

---

- Variables
- Conditionals
- Loops (or GOTOs)
- Print statements

???

Print Statements =~ some way to affect the world. The first
three items give you Turing-completeness; the fourth lets
you actually do stuff.

---

???

I programmed in Visual Basic for 10 years, primarily making
games for myself and my friends. I only knew about
variables, ifs, loops, and a UI library. The only data types
I knew about were the built-in primitive types, which
included fixed-length arrays. I didn't really understand
variable scoping, or why you would ever want to create a
function that wasn't an entry point to your program. I'd be
willing to bet that I have more experience being a naive
programmer than anyone else in this room.

For those ten years, I was programming without any thought
of imposing style on my programs. I judged code by one
metric: did it work? If it works, it's good.

---

???

So, wouldn't you like to see some of that code? Well,
unfortunately, I don't have any of it. I wrote it all on my
dad's Windows box, which he sold or gave away when I was in
high school, and since then I haven't bothered to acquire a
computer capable of running those programs, and I have no
idea if any copies of them even still exist.

But it's not too hard to imagine how you'd program
this way. You can do it in basically any imperative
language. You just have to follow one simple rule:

- Do not create any functions, except as absolutely
  necessary to create entry points to your program (e.g. for
  click event handlers)

---

class: center, middle

## _&ldquo;Duplication is far cheaper than the wrong abstraction.&rdquo;_

<cite>Sandi Metz</cite>

???

Programming this way has many downsides and I'm definitely
not advocating that you do this seriously. But if you write
programs this way, you avoid a particular type of mistake,
which is creating the wrong abstractions.

But this quote kind of implies that duplication and
abstraction are opposites. They're not. You can eliminate
some types of duplication without creating any new
abstractions.

---

## Duplication and abstraction are not opposites

---

## Detour: Why is imperative programming the natural paradigm for beginners?

- Pedagogical
  - Robots!
  - No paradigm shift as you drill down towards the metal
  - Analogizes to pen-and-paper calculation
- Technological
  - Debuggers
- Essential
  - Possible to write significant programs without introducing
    any new abstractions

???

All of this seems to presuppose that imperative programming
is the way that beginners naturally program. But that's far
from obvious. It could be that programming tutorials for
beginners focus on imperative code because that's the
natural way, but it could also be that beginners program in
an imperative style because that's the way they're taught.
Which came first? The student or the teacher?

---

class: center, middle

```lisp
(defun multiply-poly (p1 p2)
  (cond ((null p1) nil)
        (t (add-poly
             (constant-multiply-poly (car p1) p2)
             (cons 0 (multiply-poly (cdr p1) p2))))))
```

<cite>Richard Gabriel</cite>

???

Here's some code written by a master Lisp programmer,
Richard Gabriel. It multiplies two polynomials, represented
as lists of the coefficients of their terms. It relies on
two helper functions, `add-poly` and `multiply-poly`, and
a recursive call. The helper functions (not shown here)
also involve recursive calls.

Because functional programming relies so heavily on
recursion, it's virtually impossible to construct a program
without creating and naming new abstractions. Creating these
abstractions involves a level of design foresight and
problem-solving ability that most beginners don't yet have.

Therefore, I feel confident in stating that the naive
approach to programming will always be imperative.

---

class: center, middle

### _&ldquo;When you were new to programming, you wrote simple code. Although you may not have appreciated it at the time, this was a great strength.&rdquo;_

#### —Sandi Metz & Katrina Owen, _99 Bottles of OOP_

???

This is the first sentence of Sandi Metz and Katrina Owen's
book _99 Bottles of OOP_. And it's probably true. Beginners'
code is simple in some sense, if only because it uses a
highly constrained set of forms.

---

class: center, middle

### _&ldquo;I personally thought that maybe there was no good solution to this problem.&rdquo;_

#### —Katrina Owen

???

Source: https://whyarecomputers.com/3

---

Simplicity, as Alexander defines it, is the absence of
arbitrary distinctions, and therefore the opposite of style.

---

## Act Five: The Timeless Way of Programming

---

> In our time, many of us have been taught to strive for an insane perfection that means nothing. To get wholeness, you must try instead to strive for this kind of perfection, where things that don’t matter are left rough and unimportant, and the things that really matter are given deep attention. This is a perfection that seems imperfect. But it is a far deeper thing.

<cite>Christopher Alexander</cite>

---

## shallow hierarchies

---

## symmetry

---

## multiple paradigms

---

```ruby
download_class =
  case uri.scheme
  when "ssh"
    GitDownload
  when "https"
    HttpsDownload
  when "sftp"
    SftpDownload
  end
```

---

## shallow mess

---

> When I'm working on a problem, I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.

<cite>R. Buckminster Fuller</cite>

---

## References

- Christopher Alexander
  - _The Timeless Way of Building_
  - _A Pattern Language_
  - _The Nature of Order_
- Kent Beck
  - _Extreme Programming Explained, 2nd. Ed_
- Sandi Metz & Katrina Owen
  - _99 Bottles of OOP_
- Sarah Mei
  - "Livable Code"
- Anjana Vakil
  - "Programming Across Paradigms"
- Jessica Kerr
  - "Functional Principles for Object-Oriented Developers"
- Richard Gabriel
  - _Patterns of Software: Tales from the Software Community_

    </textarea>
    <script src="./remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
